5-feb-2018
==========

Learning Python

Python is designed to be readable, and has support for Object-oriented 
programming and functional programming, which are software-reuse mechanisms.

Python code is typically 1/3 to 1/5 the size of equivalent C++ or Java code.
This means less typing, less debugging, and less maintaining. It doesn't
need to compile so it can run immediately.

Porting between Mac and Windows is trivial.

A powerful advantage is having so many 3rd-party tools. Even free NumPy has been 
described as being more pwerful than Matlab. 

Python seems to "fit your brain", in that the language is consistent and 
its features interact in limited ways, and arise naturally from core concepts.

Python adopts a minimalist approach. There is usually just one obvious way to
approach a coding task and few less obvious alternatives. Explicit is better
than implicit - simple is better than complex.

Python was designed to get more done with less effort. It is deliberately
optimized for speed of development. 

Typing "import this" at the Python interpreter prompt gives "The Zen of Python".

Python is a general-purpose programming language that blends procedural,
functional, and object-oriented paradigms. 

One downside to python is that it's not as fast as C and C++, since it's not
a fully-compiled-low-level language. 

Standard implementations of Python convert source code to byte code, and then
interpret the byte code. Byte code allows for portability, since it is platform-
independent. It is however not compiled all the way down to binary machine code,
thus why it'll be slower than fully compiled languages like C. PyPy can achieve
10x to 100x speedup by compiling further, but it's a separate and alternative
implementation.

Oftentimes, when needing speed, Python interpreter can hand off tasks to 
compiled C code - so the Python script can run at C speed. Python's speed-of-
development is often more important than speed-of-execution loss, especially
as computers get faster - but sometimes you do need fast, like numeric
programming and animation. 

If we need speed, we can split the parts that need it into compiled extensions.
Compiled extensions won't be talked much about here, but NumPy does it.

Another downside is Python changing and evolving so much. It's hard to teach,
which is why the book is so big. But it is still simpler than its alternatives
like Java, etc...

The "libraries included" approach can also have drawbacks. This includes relying
on libraries which may not be well maintained, or not understanding completely
a particular tool. It can be nice for beginners, though, looking to be 
productive.

It also gives falls into some open source traps - such as the personal 
preference of the few triumphs over the common usage of the many.

Python is very stable and robust, and has been around for over 25 years, and has
a large community, with the BDFL (Benevolent Dictator for Life) at the helm 
(Guido van Rossum). (He's the creator.)

Python is written in portable ANSI C, and compiles and runs on virtually every
platform: Linux/Unix, Windows, Mac, Cray supercomputers, Palm OS, Symbian,
Windows Mobile, Android, iOS, etc...

Python's "powers":

 - Dynamic typing: Python keeps track of the types of objects the program
 uses as it runs - no such thing as type or variable declaration anywhere.

 - Automatic memory management - allocates objects and reclaims (garbage
 collection) them - most can grow and shrink on demand. 

 - Includes tools like modules, classes, and exceptions.

 - Built-in object types - provides commonly used data structures - like lists,
 dictionaries, and strings.

 - Built in tools: Standard operations, like joining collections slicing,
 sorting, mapping, etc...

Python is named after Monty Python - not the snake. So there might be some
joke references throughout the code.

The author believes that freedom of expression is great for art, but lousy
for engineering. It's harder to read and maintain if the programmer is too
unique or ticky. A code written with too much freedom is often easier to
write from scratch than to maintain.


6-feb-2018
==========

Python is a programming language, but it's also a software package called an
interpreter. The interpreter reads the program an carries out the instructions.
It's a layer of software logic between the code and the hardware.

Depending on how it's ran, the Python interpreter can be a C program, a set of
Java classes, or otherwise. 

A Python interpreter must be installed on the computer.

Python program files end in .py, but technically speaking, only files that need
to be imported need to have this extension. Regardless, all python scripts and 
files are given the .py extension for consistency.

When a python program is executed, it is first converted to byte code. Byte code
is a lower-level representation of the source code. Byte code is ran faster than
source code. This byte code is stored with a .pyc extension. 

Before Python3.2, the byte code is saved with .pyc extension in the same 
directory as the source code files. In Python3.2 and later, these .pyc files
are stored in a new subdirectory called __pycache__

The byte code is recreated if the source code changes, and this is 
monitored through the timestamp. Not recreating the byte code saves the time in
the compilation step. If python is being ran with a different version, then
the byte code is also recreated.

If python can't write the byte code to the machine, for instance if it doesn't
have the permission, then it will generate it in memory and it will be discarded
when the program exits.

To run a program, all you really need are the byte code files - and these can
be shipped around as "frozen binaries" if included with the PVM (described 
below).

Byte code is only saved for files that are imported - not for top level files
that are only ran as scripts. It's an import optimization.

Byte code is never saved for code typed at the interactive prompt.

Once the byte code is loaded from .pyc files, it is shipped off for execution 
to the Python Virtual Machine (PVM). The PVM just runs through the byte code 
instructions.

Most of this stuff is hidden from the programmer.

Compared to C/C++, there's no build or "make" step - the code run immediately 
after it is written. Also, byte code is not binary machine code, which are 
instructions for an Intel chip for instance. Byte code is a Python-specific 
representation. It's also why Python is slower than C/C++, but still faster 
than traditional interpreted languages (because of the internal compile step).

The systems that compile and execute the source code in Python are the same. 
This is different than languages like C/C++. It makes the development cycle
faster - no need to precompile and link.

The eval and exec built-ins can run string containing Python code - it allows 
for changes to the Python program on the fly without having to compile the 
whole system. There is only runtime, and not compile time. Everything happens
as the program is running. 

The execution model just described is not a requirement of Python, and there 
are a few variants. The most common are CPython, Jython, IronPython, Stackless,
and PyPy. All of them implement the same Python language but are executed 
differently. The one used in this book is CPython, which is really the standard.
The other implementations have specific purposes, such as direct access to Java 
(Jython) or .NET (IronPython).

CPython is coded in portable ANSI C language. Because it is standard, it tends 
to be the fastest, more complete, and more up-to-date. 

Jython allows .py text files to compile to Java byte code to be shipped to
the JVM. Jython makes python code feel like a true Java program at runtime.

Stackless Python allows for concurrency and provides for efficient 
multiprocessing options. The microthreads that Stackless adds are an efficient 
and lightweight alternative to Python's standard multitasking tools such as 
threads and processes. 

PyPy is focused on performance, and has a fast Python JIT (just-in-time) 
compiler. It includes Stackless Python's systems to support massive concurrency. 
It translates portions of the byte code all the way to binary code for faster 
execution. It does this as the program is running, not as a precompiled step. 
It keeps track of the data types of the objects that the program processes, and 
the program runs faster and faster as it executes. It can even take up less 
memory. It runs most CPython code C extension modules generally need to be 
recompiled. There is also some non-traditional garbage collection where files 
may need to be manually flushed. It's claimed to be a 5.7x speedup over CPython.
It can sometimes run as fast as C code, and occasionally faster. 

(Looking on the internet, NumPy is pretty fast and I wouldn't need to bother 
with PyPy when I'm doing NumPy numberic stuff.)

There are methods to get "frozen binaries", so that you can ship your program 
around, but are not true compilers. For Windows, there is py2exe, and for 
Mac OSx there is py2app. It's not the same as a true compiler - they run byte 
code through a virtual machine, and run at the same speed as the original 
source files. 

7-feb-2018
==========

The Python interpreter prints the result after each command. For instance, 
you can just type "2 ** 8", instead of "print(2 ** 8)". The code is executed 
immediately after pressing the Enter key. 

At the Python interactive prompt, if you do a compound statement (like
multiline), then pressing Enter twice runs the statement (or submitting a blank 
statement). This means you can't cut and paste multiple lines of code - unless 
the code includes blank lines after each compound statement. It's better to 
run this type of code in a file. 

You write your code into files, called modules. It's also refer to as a program,
which is a series of precoded statements, intended for repeated execution. 

The following is stream redirection and the output lines are saved in a file:

% python script1.py > saveit.txt 

When importing, Python omits the ".py" extension and the directory path, 
like so:

$ import script1 

To make a Unix-style executable script, start the script off with a hashbang 
followed by the path to the Python interpreter, e.g.,

#!/usr/local/bin/python 

Then give it executable priviliges, and you can run it in an executable way. 
This is a special thing that you can do on Unix. Unix looks for the firt line 
of a script with the #! pattern to find an interpreter for running the program. 
The usual naming convention for executable is not to have a .py extension, 
to make it clear that no other modules will import this file, and that it is 
also an executable. 

To avoid hardcoding the path to the Python interpreter, you can use the env 
program which locates the Python interpreter according to the system search 
path settings - usually by looking at directories listed in the PATH environment 
variable:

!#/usr/bin/env python 

This actually makes it more portable, and is actually recommended - some 
platforms could install Python elsewhere. However, it assumes that env will 
live on the same path everywhere, which isn't always the case (sbin instead of 
bin).

No special code or syntax is required to make a file a module - just that the 
extension needs to be ".py". 

The typical Python architecture is a top-level script that runs line by line 
and and import tools from other modules files, which may in turn import tools 
from other module files, etc... 

Import only runs once per session - they are to expensive to repeat, since 
they find files, compile them to byte code, and run the code. 

>>> import script1

Running the import again is possible, by calling the reload function in the 
imp standard library:

>>> from imp import reload 
>>> reload(script1)

The from statement copies a name out of a module, so you can use it as if the 
module was defined in the current script (e.g., you don't have to write: 
imp.reload(script1))

This allows for editting new code on the fly. 









